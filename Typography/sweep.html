<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Canvas Wall Sweep — Optimized + No Shadow + Gradient Stops</title>
<style>
  :root { --ui-bg:#111; --ui-border:#1f1f1f; }

  body{
    margin:0; background:#000; color:#ddd; min-height:100svh;
    font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial,"Noto Sans",sans-serif;
    display:grid; grid-template-rows:auto 1fr;
  }

  #controls{
    display:grid; gap:.75rem;
    grid-template-columns:repeat(6,minmax(140px,1fr));
    padding:12px 16px; background:var(--ui-bg); border-bottom:1px solid var(--ui-border);
    align-items:end;
  }
  #controls label{ font-size:.9rem; display:flex; flex-direction:column; gap:.35rem }
  #controls input,#controls select,#controls textarea,#controls button{
    background:#1a1a1a; color:#fff; border:1px solid #2a2a2a; border-radius:6px; padding:.5rem .6rem
  }
  #controls textarea{ resize:vertical; min-height:42px }
  #controls button{ cursor:pointer; }
  .span-2{ grid-column:span 2 } .span-3{ grid-column:span 3 } .span-6{ grid-column:span 6 }
  @media (max-width:900px){
    #controls{ grid-template-columns:1fr 1fr }
    .span-2,.span-3,.span-6{ grid-column:span 2 }
  }

  .stage{
    position:relative; overflow:hidden;
    background: radial-gradient(1100px 800px at 20% 40%, #060606 0%, #020202 50%, #000 100%);
  }
  canvas{ width:100%; height:100%; display:block; }

  /* Gradient editor */
  .gradWrap{ display:flex; flex-direction:column; gap:.5rem; }
  .gradTopRow{ display:flex; gap:.5rem; align-items:center; flex-wrap:wrap; }
  .gradTopRow .hint{ font-size:.8rem; color:#aaa; margin-left:auto; }

  #gradBar{
    position:relative;
    height:34px;
    border-radius:10px;
    border:1px solid #2a2a2a;
    background: linear-gradient(90deg, rgba(255,255,255,0) 0%, rgba(255,255,255,1) 50%, rgba(255,255,255,0) 100%);
    box-shadow: inset 0 0 0 1px rgba(255,255,255,.03);
    overflow:hidden;
    user-select:none;
    touch-action:none;
  }
  .stop{
    position:absolute;
    top:50%;
    width:12px; height:12px;
    transform:translate(-50%,-50%) rotate(45deg);
    border-radius:2px;
    border:1px solid rgba(255,255,255,.55);
    background:#000;
    box-shadow: 0 0 0 2px rgba(0,0,0,.6);
  }
  .stop::after{
    content:"";
    position:absolute; inset:2px;
    border-radius:1px;
    background: rgba(255,255,255,var(--v,1));
  }
  .stop.selected{
    border-color:#fff;
    box-shadow: 0 0 0 2px rgba(0,0,0,.6), 0 0 0 2px rgba(255,255,255,.25);
  }

  .stopPanel{
    display:grid;
    grid-template-columns:1fr 1fr auto auto auto;
    gap:.5rem;
    align-items:end;
  }
  .stopPanel small{ color:#aaa; display:block; margin-bottom:.25rem; }
  .checkRow{
    display:flex; align-items:center; gap:.5rem;
    padding:.35rem .5rem;
    border:1px solid #2a2a2a; border-radius:8px;
    background:#141414;
    height:40px;
  }
  .checkRow input{ width:18px; height:18px; }
  .checkRow span{ font-size:.9rem; color:#ddd; }
</style>
</head>
<body>

<div id="controls">
  <label class="span-2">Large word (highlight mask)
    <input id="largeText" type="text" value="你好">
  </label>

  <label>Background type
    <select id="bgType">
      <option value="random" selected>Randomized</option>
      <option value="fixed">Fixed text</option>
    </select>
  </label>

  <label id="langWrap">Random script
    <select id="lang">
      <option value="alphabet">Alphabet</option>
      <option value="chinese" selected>Chinese</option>
      <option value="japanese">Japanese</option>
      <option value="korean">Korean</option>
    </select>
  </label>

  <label id="fixedWrap" class="span-2" style="display:none">Fixed background text (repeats)
    <textarea id="fixed" rows="2">你好世界</textarea>
  </label>

  <label>Animation speed (seconds)
    <input id="speed" type="number" min="2" step="1" value="10">
  </label>

  <label>Cell size (px)
    <input id="cell" type="number" min="8" step="1" value="16">
  </label>

  <label class="span-2">Sweep half-width (0.05–0.60)
    <input id="halfW" type="number" min="0.05" max="0.60" step="0.01" value="0.26">
  </label>

  <label class="span-2">Wall base brightness (0–0.25)
    <input id="wallBase" type="number" min="0" max="0.25" step="0.01" value="0.08">
  </label>

  <label class="span-2">Wall peak brightness (0–1)
    <input id="wallPeak" type="number" min="0" max="1" step="0.01" value="0.65">
  </label>

  <div class="span-6 gradWrap">
    <div class="gradTopRow">
      <div style="font-size:.9rem;">Sweep profile (gradient stops)</div>
      <button id="presetSoft" type="button">Preset: 0–10–80–10–0</button>
      <button id="presetSharp" type="button">Preset: 0–100–0</button>
      <div class="hint">Click bar to add • Drag stops • Select to edit</div>
    </div>

    <div id="gradBar" aria-label="Gradient editor"></div>

    <div class="stopPanel">
      <label>
        <small>Stop position (0–1)</small>
        <input id="stopPos" type="number" min="0" max="1" step="0.01" value="0.50">
      </label>

      <label>
        <small>Stop value (0–1)</small>
        <input id="stopVal" type="number" min="0" max="1" step="0.01" value="0.80">
      </label>

      <div class="checkRow" title="Forces intensity=0 outside the sweep window (soft entry/exit)">
        <input id="lockEnds" type="checkbox" checked />
        <span>Lock ends to 0</span>
      </div>

      <button id="deleteStop" type="button">Delete</button>
      <button id="copyStops" type="button">Copy JSON</button>
    </div>
  </div>
</div>

<div class="stage" id="stage">
  <canvas id="c"></canvas>
</div>

<script>
(() => {
  const stage = document.getElementById('stage');
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha:true });

  // Offscreen base wall cache (twinkle + base brightness)
  const bgCanvas = document.createElement('canvas');
  const bgCtx = bgCanvas.getContext('2d', { alpha:true });

  // Offscreen mask (grid-res) for highlight word
  const maskCanvas = document.createElement('canvas');
  const maskCtx = maskCanvas.getContext('2d', { willReadFrequently:true });

  // UI
  const inpText = document.getElementById('largeText');
  const inpType = document.getElementById('bgType');
  const selLang = document.getElementById('lang');
  const wrapLang  = document.getElementById('langWrap');
  const wrapFixed = document.getElementById('fixedWrap');
  const txtFixed = document.getElementById('fixed');

  const inpSpeed = document.getElementById('speed');
  const inpCell  = document.getElementById('cell');
  const inpHalfW = document.getElementById('halfW');
  const inpWallBase = document.getElementById('wallBase');
  const inpWallPeak = document.getElementById('wallPeak');

  // Gradient UI
  const gradBar   = document.getElementById('gradBar');
  const stopPosEl = document.getElementById('stopPos');
  const stopValEl = document.getElementById('stopVal');
  const delStopEl = document.getElementById('deleteStop');
  const copyStops = document.getElementById('copyStops');
  const presetSoft = document.getElementById('presetSoft');
  const presetSharp = document.getElementById('presetSharp');
  const lockEndsEl = document.getElementById('lockEnds');

  // State
  let dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  let cell = 16;
  let cols = 0, rows = 0;

  // Wall chars + twinkle
  let chars = null;     // Uint32Array of codepoints
  let twPhase = null;   // Float32Array
  let twSpeed = null;   // Float32Array

  // Highlight mask + indices
  let highlightMask = new Uint8Array(0);
  let hiByCol = [];     // Array<Uint32Array>

  // Column normalization (0..1)
  let colNorm = new Float32Array(0);

  // Base wall cache updates
  const BG_FPS = 12;
  let bgDirty = true;
  let lastBgTs = 0;

  // Animation
  let waveOffset = Math.random();

  // Stops (Figma-like)
  let stops = [
    { p: 0.00, v: 0.00 },
    { p: 0.15, v: 0.10 },
    { p: 0.50, v: 0.80 },
    { p: 0.85, v: 0.10 },
    { p: 1.00, v: 0.00 },
  ];
  let selectedStop = stops[2] || null;
  let dragging = null;

  function clamp(n,a,b){ return Math.min(b, Math.max(a, n)); }
  function sortStops(){ stops.sort((a,b)=>a.p-b.p); }

  function syncUI(){
    const isRandom = inpType.value === 'random';
    wrapLang.style.display  = isRandom ? '' : 'none';
    wrapFixed.style.display = isRandom ? 'none' : '';
  }

  function randomCodepoint(set){
    switch(set){
      case 'alphabet': return 33 + Math.floor(Math.random()*94);
      case 'chinese':  return 0x4E00 + Math.floor(Math.random()*2000);
      case 'japanese': return (Math.random()<0.6)
        ? (0x3041 + Math.floor(Math.random()*86))
        : (0x30A1 + Math.floor(Math.random()*86));
      case 'korean':   return 0xAC00 + Math.floor(Math.random()*1115);
      default:         return 63;
    }
  }

  function wavePeriodMs(){
    const seconds = Math.max(0.5, Number(inpSpeed.value) || 10);
    return seconds * 1000;
  }

  function evalGradient(u){
    if (lockEndsEl.checked){
      if (u <= 0 || u >= 1) return 0;
    }
    if (!stops.length) return 0;
    sortStops();

    if (u <= stops[0].p) return stops[0].v;
    const last = stops[stops.length - 1];
    if (u >= last.p) return last.v;

    for (let i=0;i<stops.length-1;i++){
      const a = stops[i], b = stops[i+1];
      if (u >= a.p && u <= b.p){
        const t = (u - a.p) / Math.max(1e-6, (b.p - a.p));
        return a.v + (b.v - a.v) * t;
      }
    }
    return 0;
  }

  function rebuild(){
    cell = Math.max(8, Number(inpCell.value) || 16);

    const wCss = stage.clientWidth;
    const hCss = stage.clientHeight;

    cols = Math.max(1, Math.ceil(wCss / cell));
    rows = Math.max(1, Math.ceil(hCss / cell));

    // canvases in device pixels
    const cw = Math.floor(wCss * dpr);
    const ch = Math.floor(hCss * dpr);
    if (canvas.width !== cw || canvas.height !== ch){ canvas.width = cw; canvas.height = ch; }
    if (bgCanvas.width !== cw || bgCanvas.height !== ch){ bgCanvas.width = cw; bgCanvas.height = ch; }

    // mask at grid resolution
    maskCanvas.width = cols;
    maskCanvas.height = rows;

    // norms
    colNorm = new Float32Array(cols);
    const denom = Math.max(1, cols - 1);
    for (let c=0;c<cols;c++) colNorm[c] = cols > 1 ? (c / denom) : 0;

    // chars + twinkle
    const total = cols * rows;
    chars = new Uint32Array(total);
    twPhase = new Float32Array(total);
    twSpeed = new Float32Array(total);

    const mode = inpType.value;
    const script = selLang.value;
    const fixedStr = (txtFixed.value && txtFixed.value.trim()) ? txtFixed.value.trim() : '你好世界';
    const fixedCps = Array.from(fixedStr);
    const fixedLen = fixedCps.length || 1;
    let fi = 0;

    for (let i=0;i<total;i++){
      const cp = (mode === 'random')
        ? randomCodepoint(script)
        : fixedCps[fi++ % fixedLen].codePointAt(0);
      chars[i] = cp;
      twPhase[i] = Math.random() * Math.PI * 2;
      twSpeed[i] = 0.15 + Math.random() * 0.35;
    }

    rasterizeWord(inpText.value);
    bgDirty = true;
  }

  function rasterizeWord(word){
    if (!cols || !rows) return;

    maskCtx.clearRect(0,0,cols,rows);

    const cleaned = (word || ' ')
      .replace(/\r\n?/g, '\n')
      .replace(/\\n/g, '\n');
    const lines = cleaned.split('\n').map(l => l.length ? l : ' ');

    const families = '"Times New Roman","Georgia","Times",serif';
    let size = Math.max(4, Math.min(cols, rows));

    const maxW = cols * 0.9;
    const maxH = rows * 0.9;

    function measure(sz){
      maskCtx.font = `700 ${sz}px ${families}`;
      let maxLineWidth = 1, maxA = 0, maxD = 0;
      const per = [];
      for (const line of lines){
        const m = maskCtx.measureText(line);
        const left = m.actualBoundingBoxLeft ?? 0;
        const right = m.actualBoundingBoxRight ?? (m.width ?? 0);
        const width = Math.max(m.width || 0, left + right, 1);
        const a = m.actualBoundingBoxAscent || sz*0.8;
        const d = m.actualBoundingBoxDescent || sz*0.2;
        maxLineWidth = Math.max(maxLineWidth, width);
        maxA = Math.max(maxA, a);
        maxD = Math.max(maxD, d);
        per.push({ a, d });
      }
      const lead = sz*0.2;
      const lh = maxA + maxD + lead;
      const first = per[0], last = per[per.length-1];
      const totalH = first.a + last.d + Math.max(0, per.length-1)*lh;
      return { maxLineWidth, totalH, lh, per };
    }

    let m = measure(size);
    for (let i=0;i<7;i++){
      const scale = Math.min(maxW / m.maxLineWidth, maxH / Math.max(1, m.totalH));
      if (scale >= 0.995) break;
      size = Math.max(4, size * scale);
      m = measure(size);
    }

    maskCtx.fillStyle = '#fff';
    maskCtx.textAlign = 'center';
    maskCtx.textBaseline = 'alphabetic';
    maskCtx.font = `700 ${size}px ${families}`;

    const first = m.per[0], last = m.per[m.per.length-1];
    const totalH = first.a + last.d + Math.max(0, lines.length-1)*m.lh;
    let y = rows/2 - totalH/2 + first.a;

    for (let i=0;i<lines.length;i++){
      maskCtx.fillText(lines[i], cols/2, y);
      y += m.lh;
    }

    const data = maskCtx.getImageData(0,0,cols,rows).data;

    const total = cols * rows;
    if (highlightMask.length !== total) highlightMask = new Uint8Array(total);

    const tmp = Array.from({ length: cols }, () => []);
    const TH = 64;

    for (let i=0;i<total;i++){
      const on = data[i*4 + 3] > TH;
      highlightMask[i] = on ? 1 : 0;
      if (on) tmp[i % cols].push(i);
    }
    hiByCol = tmp.map(a => Uint32Array.from(a));
  }

  function updateBaseWall(now){
    const interval = 1000 / BG_FPS;
    if (!bgDirty && (now - lastBgTs) < interval) return;
    lastBgTs = now;
    bgDirty = false;

    const wCss = stage.clientWidth;
    const hCss = stage.clientHeight;

    bgCtx.setTransform(1,0,0,1,0,0);
    bgCtx.clearRect(0,0,bgCanvas.width,bgCanvas.height);
    bgCtx.setTransform(dpr,0,0,dpr,0,0);

    const wallBase = clamp(Number(inpWallBase.value) || 0.08, 0, 0.25);
    const fontPx = Math.max(6, cell - 4);

    bgCtx.font = `${fontPx}px ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Noto Sans Mono",monospace`;
    bgCtx.textAlign = 'center';
    bgCtx.textBaseline = 'middle';

    const time = now * 0.001;

    // Base wall includes ALL cells, even highlight (highlight will be drawn over)
    for (let r=0; r<rows; r++){
      const y = r * cell + cell/2;
      if (y < -cell || y > hCss + cell) continue;

      for (let c=0; c<cols; c++){
        const x = c * cell + cell/2;
        if (x < -cell || x > wCss + cell) continue;

        const i = r*cols + c;

        // twinkle only affects base layer
        const tw = 0.86 + 0.14 * Math.sin(twPhase[i] + time * twSpeed[i]);
        const a = wallBase * tw;

        bgCtx.fillStyle = `rgba(255,255,255,${a.toFixed(4)})`;
        bgCtx.fillText(String.fromCodePoint(chars[i]), x, y);
      }
    }
  }

  function draw(now){
    if (!cols || !rows){
      requestAnimationFrame(draw);
      return;
    }

    now = now || performance.now();
    updateBaseWall(now);

    // Copy base wall
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.drawImage(bgCanvas, 0, 0);

    ctx.setTransform(dpr,0,0,dpr,0,0);

    const wallBase = clamp(Number(inpWallBase.value) || 0.08, 0, 0.25);
    const wallPeak = clamp(Number(inpWallPeak.value) || 0.65, 0, 1);
    const boostMax = Math.max(0, wallPeak - wallBase);

    const halfW = clamp(Number(inpHalfW.value) || 0.26, 0.05, 0.60);

    // Travel off-screen for soft entry/exit (prevents “square window” look)
    const period = wavePeriodMs();
    const t = ((now / period) + waveOffset) % 1;

    const overscan = halfW + 0.10;
    const center = (-overscan) + t * (1 + 2*overscan);

    const left = center - halfW;
    const right = center + halfW;

    // Affected column range only (major perf win)
    const lo = Math.max(0, Math.floor(left * (cols - 1)));
    const hi = Math.min(cols - 1, Math.ceil(right * (cols - 1)));

    // Sweep overlay: draw only affected band columns, non-highlight cells only
    if (boostMax > 0.0005){
      const fontPx = Math.max(6, cell - 4);
      ctx.font = `${fontPx}px ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Noto Sans Mono",monospace`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      for (let c=lo; c<=hi; c++){
        const rx = colNorm[c];
        const u = (rx - left) / Math.max(1e-6, (2*halfW)); // window-local 0..1
        const intensity = clamp(evalGradient(u), 0, 1);
        const alpha = boostMax * intensity;
        if (alpha <= 0.0005) continue;

        ctx.fillStyle = `rgba(255,255,255,${alpha.toFixed(4)})`;

        for (let r=0; r<rows; r++){
          const i = r*cols + c;
          if (highlightMask[i]) continue; // sweep does NOT touch highlight word
          const x = c * cell + cell/2;
          const y = r * cell + cell/2;
          ctx.fillText(String.fromCodePoint(chars[i]), x, y);
        }
      }
    }

    // Highlight word: pinned brightness, serif font (not affected by sweep)
    const HI_ALPHA = 0.98;
    if (HI_ALPHA > 0.0005){
      const fontPx = Math.max(6, cell - 4);
      ctx.font = `700 ${fontPx}px "Times New Roman","Georgia","Times",serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = `rgba(255,255,255,${HI_ALPHA.toFixed(4)})`;

      for (let c=0; c<cols; c++){
        const idxs = hiByCol[c];
        if (!idxs || idxs.length === 0) continue;
        for (let k=0; k<idxs.length; k++){
          const i = idxs[k];
          const r = (i / cols) | 0;
          const x = c * cell + cell/2;
          const y = r * cell + cell/2;
          ctx.fillText(String.fromCodePoint(chars[i]), x, y);
        }
      }
    }

    requestAnimationFrame(draw);
  }

  // ===== Gradient UI =====
  function cssGradientFromStops(){
    sortStops();
    const parts = stops.map(s => `rgba(255,255,255,${clamp(s.v,0,1)}) ${Math.round(s.p*100)}%`);
    return `linear-gradient(90deg, ${parts.join(', ')})`;
  }

  function renderStopsUI(){
    gradBar.style.background = cssGradientFromStops();
    gradBar.querySelectorAll('.stop').forEach(n => n.remove());

    for (const s of stops){
      const h = document.createElement('div');
      h.className = 'stop';
      h.style.left = `${(s.p*100).toFixed(3)}%`;
      h.style.setProperty('--v', clamp(s.v,0,1).toFixed(3));
      if (s === selectedStop) h.classList.add('selected');

      h.addEventListener('pointerdown', (e) => {
        e.preventDefault();
        selectedStop = s;
        renderStopsUI();
        const rect = gradBar.getBoundingClientRect();
        dragging = { stop: s, pointerId: e.pointerId, rectLeft: rect.left, rectW: rect.width };
        h.setPointerCapture(e.pointerId);
      });

      gradBar.appendChild(h);
    }

    if (selectedStop){
      stopPosEl.disabled = false;
      stopValEl.disabled = false;
      delStopEl.disabled = stops.length <= 2;
      stopPosEl.value = selectedStop.p.toFixed(2);
      stopValEl.value = selectedStop.v.toFixed(2);
    } else {
      stopPosEl.disabled = true;
      stopValEl.disabled = true;
      delStopEl.disabled = true;
    }
  }

  function addStop(p, v){
    p = clamp(p,0,1);
    v = clamp(v,0,1);
    const s = { p, v };
    stops.push(s);
    sortStops();
    selectedStop = s;
    renderStopsUI();
  }

  function deleteSelectedStop(){
    if (!selectedStop) return;
    if (stops.length <= 2) return;
    const idx = stops.indexOf(selectedStop);
    if (idx >= 0) stops.splice(idx, 1);
    selectedStop = stops[Math.max(0, idx-1)] || stops[0] || null;
    renderStopsUI();
  }

  gradBar.addEventListener('pointerdown', (e) => {
    if (e.target !== gradBar) return;
    const rect = gradBar.getBoundingClientRect();
    const p = clamp((e.clientX - rect.left) / rect.width, 0, 1);

    // default v = current interpolation at p (ignoring lock)
    sortStops();
    let v = 0;
    if (p <= stops[0].p) v = stops[0].v;
    else if (p >= stops[stops.length-1].p) v = stops[stops.length-1].v;
    else {
      for (let i=0;i<stops.length-1;i++){
        const a = stops[i], b = stops[i+1];
        if (p >= a.p && p <= b.p){
          const t = (p - a.p) / Math.max(1e-6, (b.p - a.p));
          v = a.v + (b.v - a.v) * t;
          break;
        }
      }
    }
    addStop(p, v);
  });

  gradBar.addEventListener('pointermove', (e) => {
    if (!dragging || e.pointerId !== dragging.pointerId) return;
    e.preventDefault();

    let p = clamp((e.clientX - dragging.rectLeft) / dragging.rectW, 0, 1);
    dragging.stop.p = p;

    sortStops();
    const idx = stops.indexOf(dragging.stop);
    if (idx > 0) dragging.stop.p = Math.max(dragging.stop.p, stops[idx-1].p + 0.001);
    if (idx < stops.length-1) dragging.stop.p = Math.min(dragging.stop.p, stops[idx+1].p - 0.001);
    dragging.stop.p = clamp(dragging.stop.p, 0, 1);

    renderStopsUI();
  });

  gradBar.addEventListener('pointerup', (e) => {
    if (!dragging || e.pointerId !== dragging.pointerId) return;
    dragging = null;
  });
  gradBar.addEventListener('pointercancel', () => dragging = null);

  stopPosEl.addEventListener('input', () => {
    if (!selectedStop) return;
    selectedStop.p = clamp(Number(stopPosEl.value) || 0, 0, 1);
    sortStops();
    renderStopsUI();
  });

  stopValEl.addEventListener('input', () => {
    if (!selectedStop) return;
    selectedStop.v = clamp(Number(stopValEl.value) || 0, 0, 1);
    renderStopsUI();
  });

  delStopEl.addEventListener('click', deleteSelectedStop);

  copyStops.addEventListener('click', async () => {
    const payload = JSON.stringify(stops.map(s => ({ p:+s.p.toFixed(4), v:+s.v.toFixed(4) })));
    try { await navigator.clipboard.writeText(payload); copyStops.textContent = "Copied!"; }
    catch { copyStops.textContent = "Copy failed"; }
    setTimeout(() => (copyStops.textContent = "Copy JSON"), 900);
  });

  presetSoft.addEventListener('click', () => {
    stops = [
      { p: 0.00, v: 0.00 },
      { p: 0.15, v: 0.10 },
      { p: 0.50, v: 0.80 },
      { p: 0.85, v: 0.10 },
      { p: 1.00, v: 0.00 },
    ];
    selectedStop = stops[2];
    renderStopsUI();
  });

  presetSharp.addEventListener('click', () => {
    stops = [
      { p: 0.00, v: 0.00 },
      { p: 0.50, v: 1.00 },
      { p: 1.00, v: 0.00 },
    ];
    selectedStop = stops[1];
    renderStopsUI();
  });

  // ===== Events =====
  inpText.addEventListener('input', () => rasterizeWord(inpText.value));
  inpType.addEventListener('change', () => { syncUI(); rebuild(); });
  selLang.addEventListener('change', rebuild);
  txtFixed.addEventListener('input', rebuild);

  inpCell.addEventListener('input', rebuild);
  inpSpeed.addEventListener('input', () => { waveOffset = Math.random(); });
  inpHalfW.addEventListener('input', () => {});
  inpWallBase.addEventListener('input', () => { bgDirty = true; });
  inpWallPeak.addEventListener('input', () => {});
  lockEndsEl.addEventListener('change', () => {});

  new ResizeObserver(rebuild).observe(stage);
  window.addEventListener('resize', rebuild);

  // Init
  syncUI();
  renderStopsUI();
  rebuild();
  requestAnimationFrame(draw);
})();
</script>

</body>
</html>
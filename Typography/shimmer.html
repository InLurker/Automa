<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Canvas Char Wall + Raster Text Shimmer — Blend Fix (No Shadow)</title>
<style>
  :root { --ui-bg:#0c0c0c; --ui-border:#1a1a1a; }
  body{
    margin:0; background:#000; color:#ddd; min-height:100svh;
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans", Arial,
                 "PingFang SC","Hiragino Sans","Microsoft YaHei","Noto Sans JP","Noto Sans KR", sans-serif;
    display:grid; grid-template-rows:auto 1fr;
  }
  #controls{
    display:grid; gap:.75rem;
    grid-template-columns:repeat(6,minmax(140px,1fr));
    padding:12px 16px;
    background:var(--ui-bg);
    border-bottom:1px solid var(--ui-border);
    align-items:end;
  }
  #controls label{ font-size:.9rem; display:flex; flex-direction:column; gap:.35rem }
  #controls input,#controls select,#controls textarea,#controls button{
    background:#141414; color:#fff;
    border:1px solid #242424; border-radius:6px;
    padding:.5rem .6rem;
  }
  #controls textarea{ resize:vertical; min-height:42px }
  #controls button{ cursor:pointer; }
  .span-2{ grid-column:span 2 }
  .span-3{ grid-column:span 3 }
  .span-6{ grid-column:span 6 }
  @media (max-width:900px){
    #controls{ grid-template-columns:1fr 1fr }
    .span-2,.span-3,.span-6{ grid-column:span 2 }
  }

  .stage{ position:relative; overflow:hidden; background:#000; }
  canvas{ width:100%; height:100%; display:block; }

  /* Gradient editor */
  .gradWrap{ display:flex; flex-direction:column; gap:.5rem; }
  .gradTopRow{ display:flex; gap:.5rem; align-items:center; flex-wrap:wrap; }
  .gradTopRow .hint{ font-size:.8rem; color:#9a9a9a; margin-left:auto; }
  #gradBar{
    position:relative;
    height:34px;
    border-radius:10px;
    border:1px solid #242424;
    background: linear-gradient(90deg, rgba(255,255,255,0) 0%, rgba(255,255,255,1) 50%, rgba(255,255,255,0) 100%);
    box-shadow: inset 0 0 0 1px rgba(255,255,255,.03);
    overflow:hidden;
    user-select:none;
    touch-action:none;
  }
  .stop{
    position:absolute;
    top:50%;
    width:12px; height:12px;
    transform:translate(-50%,-50%) rotate(45deg);
    border-radius:2px;
    border:1px solid rgba(255,255,255,.55);
    background:#000;
    box-shadow: 0 0 0 2px rgba(0,0,0,.6);
  }
  .stop::after{
    content:"";
    position:absolute; inset:2px;
    border-radius:1px;
    background: rgba(255,255,255,var(--v,1));
  }
  .stop.selected{
    border-color:#fff;
    box-shadow: 0 0 0 2px rgba(0,0,0,.6), 0 0 0 2px rgba(255,255,255,.18);
  }

  .stopPanel{
    display:grid;
    grid-template-columns:1fr 1fr auto auto auto;
    gap:.5rem;
    align-items:end;
  }
  .stopPanel small{ color:#9a9a9a; display:block; margin-bottom:.25rem; }

  .checkRow{
    display:flex; align-items:center; gap:.5rem;
    padding:.35rem .5rem;
    border:1px solid #242424; border-radius:8px;
    background:#101010;
    height:40px;
  }
  .checkRow input{ width:18px; height:18px; }
  .checkRow span{ font-size:.9rem; color:#ddd; }
</style>
</head>
<body>

<div id="controls">
  <label class="span-2">Main text (rasterized)
    <input id="mainText" type="text" value="你好">
  </label>

  <label>Fill characters
    <select id="fillMode">
      <option value="random" selected>Randomized</option>
      <option value="fixed">Fixed text</option>
    </select>
  </label>

  <label id="langWrap">Random script
    <select id="lang">
      <option value="alphabet">Alphabet</option>
      <option value="chinese" selected>Chinese</option>
      <option value="japanese">Japanese</option>
      <option value="korean">Korean</option>
    </select>
  </label>

  <label id="fixedWrap" class="span-2" style="display:none">Fixed background text (repeats)
    <textarea id="fixed" rows="2">你好世界</textarea>
  </label>

  <label>Shimmer speed (seconds)
    <input id="speed" type="number" min="1" step="1" value="6">
  </label>

  <label>Cell size (px)
    <input id="cell" type="number" min="8" step="1" value="16">
  </label>

  <label class="span-2">Sweep half-width (0.05–0.50)
    <input id="width" type="number" min="0.05" max="0.50" step="0.01" value="0.22">
  </label>

  <label class="span-2">Wall brightness (0–0.25)
    <input id="bgB" type="number" min="0" max="0.25" step="0.01" value="0.06">
  </label>

  <label class="span-2">Text base brightness (0–1)
    <input id="baseB" type="number" min="0" max="1" step="0.01" value="0.12">
  </label>

  <label class="span-2">Text peak brightness (0–1)
    <input id="peakB" type="number" min="0" max="1" step="0.01" value="1.00">
  </label>

  <div class="checkRow span-2" title="If baseB is 0, draw the text at wall brightness (so it still blends)">
    <input id="followWall" type="checkbox" checked />
    <span>Base follows wall</span>
  </div>

  <label class="span-2">Wall-follow multiplier (0–3)
    <input id="followMul" type="number" min="0" max="3" step="0.05" value="1.00">
  </label>

  <div class="span-6 gradWrap">
    <div class="gradTopRow">
      <div style="font-size:.9rem;">Shimmer profile (gradient stops)</div>
      <button id="presetSoft" type="button">Preset: 0–10–80–10–0</button>
      <button id="presetSharp" type="button">Preset: 0–100–0</button>
      <div class="hint">Click bar to add • Drag stops • Select to edit</div>
    </div>

    <div id="gradBar" aria-label="Gradient editor"></div>

    <div class="stopPanel">
      <label>
        <small>Stop position (0–1)</small>
        <input id="stopPos" type="number" min="0" max="1" step="0.01" value="0.50">
      </label>

      <label>
        <small>Stop value (0–1)</small>
        <input id="stopVal" type="number" min="0" max="1" step="0.01" value="1.00">
      </label>

      <div class="checkRow" title="Keeps sweep edges soft by forcing intensity=0 outside the window">
        <input id="lockEnds" type="checkbox" checked />
        <span>Lock ends to 0</span>
      </div>

      <button id="deleteStop" type="button">Delete</button>
      <button id="copyStops" type="button" title="Copies JSON to clipboard">Copy JSON</button>
    </div>
  </div>
</div>

<div class="stage" id="stage">
  <canvas id="c"></canvas>
</div>

<script>
(() => {
  const stage = document.getElementById('stage');
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: true });

  // UI
  const inpText   = document.getElementById('mainText');
  const selFill   = document.getElementById('fillMode');
  const selLang   = document.getElementById('lang');
  const wrapLang  = document.getElementById('langWrap');
  const wrapFixed = document.getElementById('fixedWrap');
  const txtFixed  = document.getElementById('fixed');

  const inpSpeed  = document.getElementById('speed');
  const inpCell   = document.getElementById('cell');
  const inpWidth  = document.getElementById('width');
  const inpBgB    = document.getElementById('bgB');
  const inpBaseB  = document.getElementById('baseB');
  const inpPeakB  = document.getElementById('peakB');

  const chkFollow = document.getElementById('followWall');
  const inpFollowMul = document.getElementById('followMul');

  // Gradient UI
  const gradBar   = document.getElementById('gradBar');
  const stopPosEl = document.getElementById('stopPos');
  const stopValEl = document.getElementById('stopVal');
  const delStopEl = document.getElementById('deleteStop');
  const copyStops = document.getElementById('copyStops');
  const presetSoft = document.getElementById('presetSoft');
  const presetSharp = document.getElementById('presetSharp');
  const lockEndsEl = document.getElementById('lockEnds');

  // Offscreen mask (grid resolution)
  const maskCanvas = document.createElement('canvas');
  const maskCtx = maskCanvas.getContext('2d', { willReadFrequently: true });

  // State
  let dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  let cell = 16;
  let cols = 0, rows = 0;

  let chars = null;     // Uint32Array
  let twPhase = null;   // Float32Array
  let twSpeed = null;   // Float32Array

  let hiByCol = [];     // Array<Uint32Array>

  let waveOffset = Math.random();
  let rebuildQueued = false;
  let rasterQueued = false;

  // Gradient stops
  let stops = [
    { p: 0.00, v: 0.00 },
    { p: 0.20, v: 0.10 },
    { p: 0.50, v: 0.80 },
    { p: 0.80, v: 0.10 },
    { p: 1.00, v: 0.00 },
  ];
  let selectedStop = null;
  let dragging = null;

  function clamp(n,a,b){ return Math.min(b, Math.max(a, n)); }
  function sortStops(){ stops.sort((a,b)=>a.p-b.p); }

  function randomChar(set){
    switch(set){
      case 'alphabet': return 33 + Math.floor(Math.random()*94);
      case 'chinese':  return 0x4E00 + Math.floor(Math.random()*2000);
      case 'japanese': return (Math.random()<0.6)
        ? (0x3041 + Math.floor(Math.random()*86))
        : (0x30A1 + Math.floor(Math.random()*86));
      case 'korean':   return 0xAC00 + Math.floor(Math.random()*1115);
      default:         return 63;
    }
  }

  function syncUI(){
    const isRandom = selFill.value === 'random';
    wrapLang.style.display  = isRandom ? '' : 'none';
    wrapFixed.style.display = isRandom ? 'none' : '';
  }

  function queueRebuild(){
    if (rebuildQueued) return;
    rebuildQueued = true;
    requestAnimationFrame(() => { rebuildQueued = false; rebuild(); });
  }

  function queueRaster(){
    if (rasterQueued) return;
    rasterQueued = true;
    requestAnimationFrame(() => { rasterQueued = false; rasterizeTextToMask(inpText.value); });
  }

  function rebuild(){
    cell = Math.max(8, Number(inpCell.value) || 16);

    const w = stage.clientWidth;
    const h = stage.clientHeight;
    cols = Math.max(1, Math.ceil(w / cell));
    rows = Math.max(1, Math.ceil(h / cell));

    const cw = Math.floor(w * dpr);
    const ch = Math.floor(h * dpr);
    if (canvas.width !== cw || canvas.height !== ch) { canvas.width = cw; canvas.height = ch; }

    const total = cols * rows;
    chars = new Uint32Array(total);
    twPhase = new Float32Array(total);
    twSpeed = new Float32Array(total);

    const mode = selFill.value;
    const script = selLang.value;
    const fixedStr = (txtFixed.value && txtFixed.value.trim()) ? txtFixed.value.trim() : '你好世界';
    const fixedCps = Array.from(fixedStr);
    const fixedLen = fixedCps.length || 1;
    let fi = 0;

    for (let i=0;i<total;i++){
      const cp = (mode === 'random')
        ? randomChar(script)
        : fixedCps[fi++ % fixedLen].codePointAt(0);
      chars[i] = cp;
      twPhase[i] = Math.random() * Math.PI * 2;
      twSpeed[i] = 0.15 + Math.random() * 0.35;
    }

    maskCanvas.width = cols;
    maskCanvas.height = rows;

    rasterizeTextToMask(inpText.value);
  }

  function rasterizeTextToMask(word){
    if (!cols || !rows) return;
    maskCtx.clearRect(0,0,cols,rows);

    const cleaned = (word || ' ')
      .replace(/\r\n?/g, '\n')
      .replace(/\\n/g, '\n');
    const lines = cleaned.split('\n').map(l => l.length ? l : ' ');

    const maxW = cols * 0.9;
    const maxH = rows * 0.9;
    const families = '"Times New Roman","Georgia","Times",serif';
    let size = Math.max(4, Math.min(cols, rows));

    function measure(sz){
      maskCtx.font = `700 ${sz}px ${families}`;
      let maxLineWidth = 1, maxA = 0, maxD = 0;
      const per = [];
      for (const line of lines){
        const m = maskCtx.measureText(line);
        const left = m.actualBoundingBoxLeft ?? 0;
        const right = m.actualBoundingBoxRight ?? (m.width ?? 0);
        const width = Math.max(m.width || 0, left + right, 1);
        const a = m.actualBoundingBoxAscent || sz*0.8;
        const d = m.actualBoundingBoxDescent || sz*0.2;
        maxLineWidth = Math.max(maxLineWidth, width);
        maxA = Math.max(maxA, a); maxD = Math.max(maxD, d);
        per.push({ a, d });
      }
      const lead = sz*0.2;
      const lh = maxA + maxD + lead;
      const first = per[0], last = per[per.length-1];
      const totalH = first.a + last.d + Math.max(0, per.length-1)*lh;
      return { maxLineWidth, totalH, lh, per };
    }

    let m = measure(size);
    for (let i=0;i<7;i++){
      const scale = Math.min(maxW / m.maxLineWidth, maxH / Math.max(1, m.totalH));
      if (scale >= 0.995) break;
      size = Math.max(4, size * scale);
      m = measure(size);
    }

    maskCtx.fillStyle = '#fff';
    maskCtx.textAlign = 'center';
    maskCtx.textBaseline = 'alphabetic';
    maskCtx.font = `700 ${size}px ${families}`;

    const first = m.per[0], last = m.per[m.per.length-1];
    const totalH = first.a + last.d + Math.max(0, lines.length-1)*m.lh;
    let y = rows/2 - totalH/2 + first.a;

    for (let i=0;i<lines.length;i++){
      maskCtx.fillText(lines[i], cols/2, y);
      y += m.lh;
    }

    const data = maskCtx.getImageData(0,0,cols,rows).data;
    const tmp = Array.from({ length: cols }, () => []);
    const TH = 64;
    const total = cols * rows;
    for (let i=0;i<total;i++){
      if (data[i*4 + 3] > TH) tmp[i % cols].push(i);
    }
    hiByCol = tmp.map(arr => Uint32Array.from(arr));
  }

  function getWavePeriodMs(){
    const seconds = Math.max(0.4, Number(inpSpeed.value) || 6);
    return seconds * 1000;
  }

  function evalGradient(u){
    if (lockEndsEl.checked){
      if (u <= 0 || u >= 1) return 0;
    }
    if (!stops.length) return 0;
    sortStops();

    if (u <= stops[0].p) return stops[0].v;
    const last = stops[stops.length - 1];
    if (u >= last.p) return last.v;

    for (let i=0;i<stops.length-1;i++){
      const a = stops[i], b = stops[i+1];
      if (u >= a.p && u <= b.p){
        const t = (u - a.p) / Math.max(1e-6, (b.p - a.p));
        return a.v + (b.v - a.v) * t;
      }
    }
    return 0;
  }

  function draw(ts){
    const wCss = stage.clientWidth;
    const hCss = stage.clientHeight;

    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.setTransform(dpr,0,0,dpr,0,0);

    const fontPx = Math.max(6, cell - 4);

    const bgB   = clamp(Number(inpBgB.value)   || 0.06, 0, 0.25);
    let baseB   = clamp(Number(inpBaseB.value) || 0.12, 0, 1);
    const peakB = clamp(Number(inpPeakB.value) || 1.00, 0, 1);

    const halfW = clamp(Number(inpWidth.value) || 0.22, 0.05, 0.50);
    const period = getWavePeriodMs();
    const t = (((ts || performance.now()) / period) + waveOffset) % 1;

    // Smooth entry/exit
    const overscan = halfW + 0.10;
    const center = (-overscan) + t * (1 + 2*overscan);
    const denom = Math.max(1, cols - 1);

    const time = (ts || performance.now()) * 0.001;

    // Draw background wall
    ctx.font = `${fontPx}px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Noto Sans Mono", monospace`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    for (let r=0; r<rows; r++){
      const y = r * cell + cell/2;
      if (y < -cell || y > hCss + cell) continue;
      for (let c=0; c<cols; c++){
        const x = c * cell + cell/2;
        if (x < -cell || x > wCss + cell) continue;
        const i = r*cols + c;
        const tw = 0.86 + 0.14 * Math.sin(twPhase[i] + time * twSpeed[i]);
        ctx.fillStyle = `rgba(255,255,255,${(bgB * tw).toFixed(4)})`;
        ctx.fillText(String.fromCodePoint(chars[i]), x, y);
      }
    }

    // Draw highlight text
    ctx.font = `700 ${fontPx}px "Times New Roman","Georgia","Times",serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    // --- FIX: if baseB is 0 and follow-wall is enabled, use bgB * multiplier as base ---
    if (baseB <= 0.0005 && chkFollow.checked){
      const mul = clamp(Number(inpFollowMul.value) || 1, 0, 3);
      // use the wall baseline brightness (not twinkle), so it stays consistent
      baseB = clamp(bgB * mul, 0, 1);
    }

    // Pass A: base (now can “blend” even when user sets baseB=0)
    if (baseB > 0.0005){
      ctx.fillStyle = `rgba(255,255,255,${baseB.toFixed(4)})`;
      for (let c=0; c<cols; c++){
        const idxs = hiByCol[c];
        if (!idxs || idxs.length === 0) continue;
        for (let k=0; k<idxs.length; k++){
          const i = idxs[k];
          const r = Math.floor(i / cols);
          ctx.fillText(String.fromCodePoint(chars[i]), c*cell + cell/2, r*cell + cell/2);
        }
      }
    }

    // Pass B: sweep boost (edges can go fully to 0)
    const boostMax = Math.max(0, peakB - baseB);
    if (boostMax > 0.0005){
      for (let c=0; c<cols; c++){
        const idxs = hiByCol[c];
        if (!idxs || idxs.length === 0) continue;

        const rx = (cols > 1) ? (c / denom) : 0;
        const left = center - halfW;
        const u = (rx - left) / Math.max(1e-6, (2 * halfW));
        const intensity = clamp(evalGradient(u), 0, 1);

        const alpha = boostMax * intensity;
        if (alpha <= 0.0005) continue;

        ctx.fillStyle = `rgba(255,255,255,${alpha.toFixed(4)})`;
        for (let k=0; k<idxs.length; k++){
          const i = idxs[k];
          const r = Math.floor(i / cols);
          ctx.fillText(String.fromCodePoint(chars[i]), c*cell + cell/2, r*cell + cell/2);
        }
      }
    }

    requestAnimationFrame(draw);
  }

  // ===== Gradient UI =====
  function cssGradientFromStops(){
    sortStops();
    const parts = stops.map(s => `rgba(255,255,255,${clamp(s.v,0,1)}) ${Math.round(s.p*100)}%`);
    return `linear-gradient(90deg, ${parts.join(', ')})`;
  }

  function renderStopsUI(){
    gradBar.style.background = cssGradientFromStops();
    gradBar.querySelectorAll('.stop').forEach(n => n.remove());

    for (const s of stops){
      const h = document.createElement('div');
      h.className = 'stop';
      h.style.left = `${(s.p*100).toFixed(3)}%`;
      h.style.setProperty('--v', clamp(s.v,0,1).toFixed(3));
      if (s === selectedStop) h.classList.add('selected');

      h.addEventListener('pointerdown', (e) => {
        e.preventDefault();
        selectStop(s);
        const rect = gradBar.getBoundingClientRect();
        dragging = { stop: s, pointerId: e.pointerId, rectLeft: rect.left, rectW: rect.width };
        h.setPointerCapture(e.pointerId);
      });

      gradBar.appendChild(h);
    }

    if (selectedStop){
      stopPosEl.disabled = false;
      stopValEl.disabled = false;
      delStopEl.disabled = stops.length <= 2;
      stopPosEl.value = selectedStop.p.toFixed(2);
      stopValEl.value = selectedStop.v.toFixed(2);
    } else {
      stopPosEl.disabled = true;
      stopValEl.disabled = true;
      delStopEl.disabled = true;
    }
  }

  function selectStop(s){ selectedStop = s; renderStopsUI(); }

  function addStop(p, v){
    const s = { p: clamp(p,0,1), v: clamp(v,0,1) };
    stops.push(s); sortStops(); selectStop(s);
  }

  function deleteSelectedStop(){
    if (!selectedStop || stops.length <= 2) return;
    const idx = stops.indexOf(selectedStop);
    if (idx >= 0) stops.splice(idx, 1);
    selectedStop = stops[Math.max(0, idx-1)] || stops[0] || null;
    renderStopsUI();
  }

  gradBar.addEventListener('pointerdown', (e) => {
    if (e.target !== gradBar) return;
    const rect = gradBar.getBoundingClientRect();
    const p = clamp((e.clientX - rect.left) / rect.width, 0, 1);

    // default v = current gradient at p (ignore lock for adding)
    sortStops();
    let v = 0;
    if (p <= stops[0].p) v = stops[0].v;
    else if (p >= stops[stops.length-1].p) v = stops[stops.length-1].v;
    else {
      for (let i=0;i<stops.length-1;i++){
        const a = stops[i], b = stops[i+1];
        if (p >= a.p && p <= b.p){
          const t = (p - a.p) / Math.max(1e-6, (b.p - a.p));
          v = a.v + (b.v - a.v) * t;
          break;
        }
      }
    }
    addStop(p, v);
  });

  gradBar.addEventListener('pointermove', (e) => {
    if (!dragging || e.pointerId !== dragging.pointerId) return;
    e.preventDefault();
    dragging.stop.p = clamp((e.clientX - dragging.rectLeft) / dragging.rectW, 0, 1);

    sortStops();
    const idx = stops.indexOf(dragging.stop);
    if (idx > 0) dragging.stop.p = Math.max(dragging.stop.p, stops[idx-1].p + 0.001);
    if (idx < stops.length-1) dragging.stop.p = Math.min(dragging.stop.p, stops[idx+1].p - 0.001);
    dragging.stop.p = clamp(dragging.stop.p, 0, 1);

    renderStopsUI();
  });

  gradBar.addEventListener('pointerup', (e) => {
    if (!dragging || e.pointerId !== dragging.pointerId) return;
    dragging = null;
  });
  gradBar.addEventListener('pointercancel', () => dragging = null);

  stopPosEl.addEventListener('input', () => {
    if (!selectedStop) return;
    selectedStop.p = clamp(Number(stopPosEl.value) || 0, 0, 1);
    sortStops();
    renderStopsUI();
  });

  stopValEl.addEventListener('input', () => {
    if (!selectedStop) return;
    selectedStop.v = clamp(Number(stopValEl.value) || 0, 0, 1);
    renderStopsUI();
  });

  delStopEl.addEventListener('click', deleteSelectedStop);

  copyStops.addEventListener('click', async () => {
    const payload = JSON.stringify(stops.map(s => ({ p:+s.p.toFixed(4), v:+s.v.toFixed(4) })));
    try { await navigator.clipboard.writeText(payload); copyStops.textContent = "Copied!"; }
    catch { copyStops.textContent = "Copy failed"; }
    setTimeout(() => (copyStops.textContent = "Copy JSON"), 900);
  });

  presetSoft.addEventListener('click', () => {
    stops = [
      { p: 0.00, v: 0.00 },
      { p: 0.15, v: 0.10 },
      { p: 0.50, v: 0.80 },
      { p: 0.85, v: 0.10 },
      { p: 1.00, v: 0.00 },
    ];
    selectedStop = stops[2];
    renderStopsUI();
  });

  presetSharp.addEventListener('click', () => {
    stops = [
      { p: 0.00, v: 0.00 },
      { p: 0.50, v: 1.00 },
      { p: 1.00, v: 0.00 },
    ];
    selectedStop = stops[1];
    renderStopsUI();
  });

  // App events
  inpText.addEventListener('input', queueRaster);
  selFill.addEventListener('change', () => { syncUI(); queueRebuild(); });
  selLang.addEventListener('change', queueRebuild);
  txtFixed.addEventListener('input', queueRebuild);

  inpCell.addEventListener('input', queueRebuild);
  inpSpeed.addEventListener('input', () => { waveOffset = Math.random(); });

  new ResizeObserver(queueRebuild).observe(stage);
  window.addEventListener('resize', queueRebuild);

  // Init
  syncUI();
  renderStopsUI();
  rebuild();
  requestAnimationFrame(draw);
})();
</script>

</body>
</html>